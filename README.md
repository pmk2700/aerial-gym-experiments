# Aerial Gym Experiments

## About Aerial Gym Simulator

The Aerial Gym Simulator is a high-fidelity, physics-based simulation platform designed for training Micro Aerial Vehicles (MAVs), such as quadrotors and multirotors, in complex and cluttered environments. It is built on top of NVIDIA Isaac Gym, leveraging GPU acceleration to support large-scale, parallel simulations of thousands of drones in real time. This simulator supports a variety of MAV configurations, including: Standard planar quadrotors, fully-actuated multirotors, and custom platforms with arbitrary rotor geometries

Each configuration is equipped with both low-level and high-level geometric controllers implemented directly on the GPU for efficient control execution.

The simulator is especially useful for learning-based control and planning methods that require extensive interaction with a physics environment. It is actively maintained and used by the Autonomous Robotics Lab at NTNU. For official documentation and reference, please visit the [NTNU Aerial Gym Github repository](https://github.com/ntnu-arl/aerial_gym_simulator)

## Installation

The Aerial Gym Simulator is built on NVIDIA Isaac Gym and supports Linux systems with Python 3.6+ and CUDA-enabled GPUs. Please follow the official installation guide for the base simulator:

**Official Setup Instructions:** [https://ntnu-arl.github.io/aerial_gym_simulator/2_getting_started/](https://ntnu-arl.github.io/aerial_gym_simulator/2_getting_started/)

NOTE: THis requires installing Issac Gym Preview 4 Release [https://developer.nvidia.com/isaac-gym/download](https://developer.nvidia.com/isaac-gym/download)

## Folder Structure and Project Overview

Understanding the folder structure of the Aerial Gym Simulator is critical for successfully setting up experiments, modifying controllers, and debugging simulation behaviors. Below is a simplified breakdown of the directory tree along with descriptions to help new users navigate the codebase effectively.

### Expected Base Directory Layout
```
aerial_gym_simulator/
├── aerial_gym/                 # Core simulator code including envs, control, robot config
├── aerial_gym.egg-info/        # Package metadata (autogenerated)
├── docs/                       # Documentation folder (can be extended)
├── resources/                  # Robot URDFs, environment assets, etc.
├── supplementary_material/     # Additional materials (figures, extra configs)
├── LICENSE                     # License file
├── mkdocs.yml                  # Configuration for MkDocs (if using for docs)
├── pyproject.toml              # Python packaging metadata
├── README.md                   # Main project description and usage
├── requirements.txt            # Python dependencies
└── setup.py                    # Setup script for pip installation
```

### Important Subfolders

- **aerial_gym/config/robot_config/** 
  Contains YAML or Python config files for each robot type. These specify:
  - URDF file path
  - Asset name and robot name
  - Mass, inertia, and collision properties

- **aerial_gym/control/** 
  Holds all geometric controllers. Look into `__init__.py` to understand which controller is used for which robot (e.g., `lee_position_control`, `lmf2_position_control`).

- **aerial_gym/envs/** 
  Environment definitions used in training or evaluation.

- **aerial_gym/examples/** 
  Sample scripts to test position control, multi-agent experiments, and benchmark scenarios. You’ll modify these to test new scenarios (e.g., payload drop, wind disturbance).


## Position Control in Aerial Gym

This section walks through a baseline position control example for a single quadrotor in Aerial Gym. It uses a pre-coded geometric controller to move the drone along a smooth figure-8 trajectory while recording position and orientation data.

---

### File: `position_control_example.py`

This script demonstrates how to:
- Load the simulator with a single quadrotor (`base_quadrotor`)
- Use a geometric controller (`lmf2_position_control`) to track a position setpoint
- Log position, orientation (quaternion), and Euler angles at each timestep
- Save the collected data to `.npz` files for later analysis or plotting

---

### What the Code Does

#### 1. Environment Setup

```python
env_manager = SimBuilder().build_env(
    sim_name="base_sim",
    env_name="empty_env",
    robot_name="base_quadrotor",
    controller_name="lmf2_position_control",
    device="cuda:0",
    num_envs=1,
    headless=args.headless,
    use_warp=args.use_warp,
)
```

This initializes a simple simulation environment with a single quadrotor and a geometric position controller. The simulation runs on the GPU (cuda:0).

#### 2. Defining the Trajectory
```python
A, B = 1.0, 1.0
omega = 0.2
z_fixed = 1.0
```
This creates a figure-8 shaped trajectory in the XY plane with constant altitude z = 1.0. At each timestep, the target [x, y, z, yaw] is computed and passed as an action to the controller.

#### 3. Main Simulation Loop
```python
for i in range(10000):
    t = i * dt
    actions[:, 0] = A * math.sin(omega * t)
    actions[:, 1] = B * math.sin(2 * omega * t)
    actions[:, 2] = z_fixed
    actions[:, 3] = 0.0
    env_manager.step(actions=actions)
```
The drone receives new target setpoints at every step and the simulation advances one step using env_manager.step().


#### 4. Data Logging
The following tensors are extracted using get_obs() at each step:
1. robot_position
2. robot_orientation
3. robot_euler_angles
```python
np.savez("collected_data/positions.npz", positions=all_positions)
np.savez("collected_data/orientations.npz", orientations=all_orientations)
np.savez("collected_data/euler_angles.npz", euler_angles=all_euler_angles)

```
The drone receives new target setpoints at every step and the simulation advances one step using env_manager.step().

#### Output Files
After simulation ends, the following files are created in the collected_data/ folder:
1. positions.npz: shape (T, 1, 3) — x, y, z over time
2. orientations.npz: shape (T, 1, 4) — quaternion
3. euler_angles.npz: shape (T, 1, 3) — roll, pitch, yaw (in radians)
These files can be loaded using NumPy and visualized using matplotlib.

#### Why This Script is Important
This is the baseline setup that all other experiments build upon.
If you're trying to simulate effects like mid-flight payload attachment or wind disturbances, you’ll be updating this exact file.

Start here, run the example, make sure .npz files are saved, and visualize the results to get familiar with the workflow.

## Author
Pranav Kulkarni — UC San Diego ERL

---
